#!/usr/bin/env python3

##
# @file  seq-align
# @desc  NA
##

### Imports

import sys
import os
from work_queue import *


### Functions

def usage(code=0):
	print('Usage: {} INPUT_FILE (.fasta)'.format(os.path.basename(sys.argv[0])))
	sys.exit(code)

### Main Execution ###

if __name__ == '__main__':

	# Parse Command Line Arguments
	if len(sys.argv) != 2:
		usage(1)

	# Create Work Queue
	try:
		q = WorkQueue(port = [9000,9100], name = 'seq-align-jq', debug_log = 'debug.log')
	except:
		print('Instantiation of Work Queue failed!')
		sys.exit(1)

	# Print Port Information
	print('Listening on port %d...' % q.port)

	# Grab Input File
	infile = "%s" % sys.argv[1]
	infile1 = 'two-items.fasta'
	outfile = 'output.txt'

	# Command to Run
	command = "./swaligntool %s %s > %s" % (infile, infile1, outfile)

	t = Task(command)

	# Specify Command Location
	t.specify_file('./swaligntool', 'swaligntool', WORK_QUEUE_INPUT, cache=True)
	t.specify_file('./swalign', 'swalign', WORK_QUEUE_INPUT, cache=True)

	# Specify Files
	t.specify_file(infile, infile, WORK_QUEUE_INPUT, cache=False)
	t.specify_file(infile1, infile1, WORK_QUEUE_INPUT, cache=True)
	t.specify_file(outfile, outfile, WORK_QUEUE_OUTPUT, cache=False)

	# Submit Task
	taskid = q.submit(t)
	print("submitted task (id# %d): %s" % (taskid, t.command))

	print("waiting for tasks to complete...")
	while not q.empty():
		t = q.wait(5)
		if t:
			print("task (id# %d) complete: %s (return code %d)" % (t.id, t.command, t.return_status))
			print('t->output = %s' % t.output)
			if t.return_status != 0:
			# The task failed. Error handling (e.g., resubmit with new parameters, examine logs, etc.) here
				None
			#task object will be garbage collected by Python automatically when it goes out of scope

	print("all tasks complete!")

	#work queue object will be garbage collected by Python automatically when it goes out of scope
	sys.exit(0)
