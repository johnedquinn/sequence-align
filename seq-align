#!/usr/bin/env python3

##
# @file  seq-align
# @desc  NA
##

### Imports

import sys
import os
import random
import string
import shutil
from work_queue import *


### Functions

def usage(code=0):
	print('Usage: {} INPUT_FILE (.fasta)'.format(os.path.basename(sys.argv[0])))
	sys.exit(code)

### Main Execution ###

if __name__ == '__main__':

	# Parse Command Line Arguments
	if len(sys.argv) != 2:
		usage(1)

	# Create Work Queue
	try:
		q = WorkQueue(port = [9000,9100], name = 'seq-align-jq', debug_log = 'debug.log')
	except:
		print('Instantiation of Work Queue failed!')
		sys.exit(1)

	# Print Port Information
	print('Listening on port %d...' % q.port)

	# Create Workspace
	base_dir = os.path.abspath('.')
	identifier = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
	workspace = f'{base_dir}/{identifier}'
	os.mkdir(workspace)

	# Grab Input File
	infile = "%s" % sys.argv[1]
	print("Infile: " + infile)
	count = len(open(infile).readlines())
	print("Count: " + str(count))

	# Check if Multiple Sequences
	if count < 2:
		print('No sequences to compare')
		sys.exit(1)

	# Compare All Sequences (But Don't Duplicate Compares)
	for i in range(1, count - 2, 2):

		# Create File Names
		in1  = f'in_{i:03d}.fasta'
		in2  = f'in_{i+1:03d}.fasta'
		out1 = f'out_{i:03d}.txt'

		# Generate Files
		os.system(f'sed -n \'{i},{i+1}p;{i+2}q\' {infile} > {workspace}/{in1}')
		os.system(f'sed -n \'{i+2},{count}p\' {infile} > {workspace}/{in2}')

		# Create Task
		command = "./swaligntool %s %s > %s" % (in1, in2, out1)
		t = Task(command)

		# Specify Command Location
		t.specify_file('./swaligntool', 'swaligntool', WORK_QUEUE_INPUT, cache=True)
		t.specify_file('./swalign', 'swalign', WORK_QUEUE_INPUT, cache=True)

		# Specify Files
		t.specify_file(f'{workspace}/{in1}', in1, WORK_QUEUE_INPUT, cache=False)
		t.specify_file(f'{workspace}/{in2}', in2, WORK_QUEUE_INPUT, cache=False)
		t.specify_file(f'{workspace}/{out1}', out1, WORK_QUEUE_OUTPUT, cache=False)

		# Submit Task
		taskid = q.submit(t)
		print("submitted task (id# %d): %s" % (taskid, t.command))

	print("waiting for tasks to complete...")
	while not q.empty():
		t = q.wait(5)
		if t:
			print("task (id# %d) complete: %s (return code %d)" % (t.id, t.command, t.return_status))
			print('t->output = %s' % t.output)
			if t.return_status != 0:
			# The task failed. Error handling (e.g., resubmit with new parameters, examine logs, etc.) here
				None
			#task object will be garbage collected by Python automatically when it goes out of scope

	print("all tasks complete!")

	#work queue object will be garbage collected by Python automatically when it goes out of scope
	shutil.rmtree(workspace)
	sys.exit(0)
